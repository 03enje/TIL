## 동적 프로그래밍 알고리즘

문제의 크기가 작은 소문제에 대한 해를 저장해 놓고, 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만들어가는 상향식(bottom-up) 접근 방법

- 각각의 소문제는 원래의 문제와 동일하지만 입력의 크기만 줄어듦

- 입력 크기가 아주 작은 단순한 문제가 되면 쉽게 해를 구할 수 있고, 이런 소문제의 해는 다시 사용될 수 있으므로 테이블에 저장

- 해당 소문제의 해가 필요할 때마다 테이블에서 결과를 바로 이용

동적 프로그래밍(동적 계획법, dynamic programming)은 컴퓨터에서의 프로그램과 무관하며 "해를 구축하는 테이블을 이용한다"의 개념

## 분할 정복 방법과의 차이점

분할 정복 방법은 상위 레벨의 큰 문제를 순환적으로 부분배열로 분할하고, 이들의 해를 결합해서 원래 문제를 해결하는 하향식 접근 방법이지만, 동적 프로그래밍 방법은 입력 크기가 작은 소문제들을 모두 해결하여 구한 해를 테이블에 저장한 후, 이 해들을 이용하여 보다 큰 크기의 문제를 해결하는 상향식 접근 방법

| 분할 정복 방법                           | 동적 프로그래밍 방법                                                                                    |
| ---------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| 하향식 접근 방법                         | 상향식 접근 방법                                                                                        |
| 분할된 작은 문제들은 서로 독립적         | 소문제들은 서로 독립적이지 않고, 중복되는 부분이 존재                                                   |
| 이진 탐색, 합병 정렬, 퀵 정렬, 선택 문제 | 피보나치 수열, 연쇄 행렬 곱셈, 스트링 편집 거리, 모든 정점 간의 최단 경로(플로이드 알고리즘), 저울 문제 |

## 동적 프로그래밍 방법을 적용하려면

최적성의 원리(principle of optimality)를 반드시 만족해야 함

주어진 문제에 대한 최적해는 주어진 문제의 소문제에 대한 최적해로 구성

## 동적 프로그래밍 방법의 적용 과정

1. 문제의 특성을 분석하여 최적성의 원리가 성립되는지 확인
2. 주어진 문제에 대해서 최적해를 제공하는 점화식을 도출
3. 가장 작은 소문제부터 점화식의 해를 구해서 테이블에 저장
4. 테이블에 저장된 소문제에 해를 이용하여 점차적으로 큰 상위 문제의 해를 구함

## 피보나치 수열

$$f(n) = {f(n-1)+f(n-2), n \ge 2 \brace f(0)=0, f(1)=1} $$

![피보나치 수열](https://user-images.githubusercontent.com/115876761/233634142-fe09152b-f117-4088-9b31-bdf4dcff80dc.png)

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

피보나치 수열을 나타내는 일반적인 방법은 다음과 같습니다.

```C
Fibo(n) {
  f[0] = 0; f[1] = 1;
  for (i = 2; i <= n; i++)
    f[i] = f[i-1] + f[i-2]
  return f[n];
}
```

하지만 분할정복 방법을 적용한다면 순환 형태의 알고리즘으로 표현할 수 있습니다.

```C
int f(n) {
  if (n <= 0) return 0;
  if (n == 1) return 1;
  else return(f(n - 1) + f(n - 2));
}
```

![순환 형태를 이용한 피보나치 수열](https://user-images.githubusercontent.com/115876761/233638614-2084c9d4-7a0b-4c32-b337-b6a4737e6032.png)

하지만 위에 순환 형태를 다음과 같은 문제점이 있습니다.

![소문제 중복](https://user-images.githubusercontent.com/115876761/233638988-84bff545-1f6d-4d3c-90a8-9d051169fc61.png)

소문제 f(2)가 독립이 아니므로 중복된 계산이 필요하여 매우 비효율적입니다.
