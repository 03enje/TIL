## 동적 프로그래밍 알고리즘

문제의 크기가 작은 소문제에 대한 해를 저장해 놓고, 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만들어가는 상향식(bottom-up) 접근 방법

- 각각의 소문제는 원래의 문제와 동일하지만 입력의 크기만 줄어듦

- 입력 크기가 아주 작은 단순한 문제가 되면 쉽게 해를 구할 수 있고, 이런 소문제의 해는 다시 사용될 수 있으므로 테이블에 저장

- 해당 소문제의 해가 필요할 때마다 테이블에서 결과를 바로 이용

동적 프로그래밍(동적 계획법, dynamic programming)은 컴퓨터에서의 프로그램과 무관하며 "해를 구축하는 테이블을 이용한다"의 개념

## 분할 정복 방법과의 차이점

분할 정복 방법은 상위 레벨의 큰 문제를 순환적으로 부분배열로 분할하고, 이들의 해를 결합해서 원래 문제를 해결하는 하향식 접근 방법이지만, 동적 프로그래밍 방법은 입력 크기가 작은 소문제들을 모두 해결하여 구한 해를 테이블에 저장한 후, 이 해들을 이용하여 보다 큰 크기의 문제를 해결하는 상향식 접근 방법

| 분할 정복 방법                           | 동적 프로그래밍 방법                                                                                    |
| ---------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| 하향식 접근 방법                         | 상향식 접근 방법                                                                                        |
| 분할된 작은 문제들은 서로 독립적         | 소문제들은 서로 독립적이지 않고, 중복되는 부분이 존재                                                   |
| 이진 탐색, 합병 정렬, 퀵 정렬, 선택 문제 | 피보나치 수열, 연쇄 행렬 곱셈, 스트링 편집 거리, 모든 정점 간의 최단 경로(플로이드 알고리즘), 저울 문제 |

## 동적 프로그래밍 방법을 적용하려면

최적성의 원리(principle of optimality)를 반드시 만족해야 함

주어진 문제에 대한 최적해는 주어진 문제의 소문제에 대한 최적해로 구성

## 동적 프로그래밍 방법의 적용 과정

1. 문제의 특성을 분석하여 최적성의 원리가 성립되는지 확인
2. 주어진 문제에 대해서 최적해를 제공하는 점화식을 도출
3. 가장 작은 소문제부터 점화식의 해를 구해서 테이블에 저장
4. 테이블에 저장된 소문제에 해를 이용하여 점차적으로 큰 상위 문제의 해를 구함

## 피보나치 수열

$$
f(n) =
\begin{cases}
f(n-1)+f(n-2), \; n \ge 2 \\
f(0)=0, f(1)=1
\end{cases}
$$

![피보나치 수열](https://user-images.githubusercontent.com/115876761/233634142-fe09152b-f117-4088-9b31-bdf4dcff80dc.png)

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

```C
Fibo(n) {
  f[0] = 0; f[1] = 1;
  for (i = 2; i <= n; i++)
    f[i] = f[i-1] + f[i-2]
  return f[n];
}
```

피보나치 수열을 나타내는 일반적인 방법은 위와 같습니다.

```C
int f(n) {
  if (n <= 0) return 0;
  if (n == 1) return 1;
  else return(f(n - 1) + f(n - 2));
}
```

분할정복 방법을 적용한다면 순환 형태의 알고리즘으로 표현할 수 있습니다.

![순환 형태를 이용한 피보나치 수열](https://user-images.githubusercontent.com/115876761/233638614-2084c9d4-7a0b-4c32-b337-b6a4737e6032.png)

하지만 위에 순환 형태는 다음과 같은 문제점이 있습니다.

![소문제 중복](https://user-images.githubusercontent.com/115876761/233638988-84bff545-1f6d-4d3c-90a8-9d051169fc61.png)

소문제 f(2)가 독립이 아니므로 중복된 계산이 필요하여 매우 비효율적입니다.

## 연쇄 행렬 곱셈

n개의 행렬을 연쇄적으로 곱하는 경우

![n개의 행렬](https://user-images.githubusercontent.com/115876761/233641213-a9c71fac-1bf4-4fb9-a1a9-3c14dfeff598.png)

위와 같이 여러개의 행렬이 존재한다면

![n개의 행렬 결합법칙](https://user-images.githubusercontent.com/115876761/233643260-6911fbe5-a6f1-4dbc-83a3-c2044004fb5c.png)

결합법칙이 성립되어 여러개의 곱셈 순서가 존재합니다.

- 연산에 필요한 곱셈의 횟수가 달라짐

## 연쇄 행렬 곱셈 문제란?

- n개의 행렬을 연쇄적으로 곱할 때 최적의 곱셈 순서를 구하는 문제

최적의 곱셈 순서 -> 최소의 기본 곱셈 횟수를 갖는 행렬의 곱셈 순서

$$M_1:30 \times 5 \quad M_2:5 \times 20 \quad M_3:20 \times 15 \quad M_4:15 \times 10 \quad$$

위와 같이 4개의 행렬이 존재한다면 총 5개의 곱셈 순서

$((M_1M_2)M_3)M_4 \rarr 30 \times 5 \times 20 + 30 \times 20 \times 15 + 30 \times 15 \times 10 = 16,500$

$M_1(M_2(M_3M_4)) \rarr 5 \times 15 \times 10 + 5 \times 20 \times 10 + 30 \times 5 \times 10 = 5,500$

$M_1((M_2M_3)M_4) \rarr 5 \times 20 \times 15 + 5 \times 15 \times 10 + 30 \times 5 \times 10 = 3,750$

$(M_1(M_2M_3))M_4 \rarr 5 \times 20 \times 15 + 30 \times 5 \times 15 + 30 \times 15 \times 10 = 6,900$

$(M_1M_2)(M_3M_4) \rarr 30 \times 5 \times 20 + 20 \times 15 \times 10 + 30 \times 20 \times 10 = 12,000$

이 중

$M_1((M_2M_3)M_4) \rarr 5 \times 20 \times 15 + 5 \times 15 \times 10 + 30 \times 5 \times 10 = 3,750$

위에 곱셈 순서가 최소의 곱셈 횟수를 가짐

## 최적성의 원리

n개의 행렬을 곱하는 최적의 순서는 n개의 행렬의 어떤 부분집합을 곱하는 최적의 순서를 포함

만약 7개의 행렬을 곱하는 최적의 순서가 다음과 같다면,

$$(M_1M_2)((((M_3M_4)M_5)M_6)M_7)$$

$M_3, M_4, M_5$를 곱하는 최적의 순서는 $((M_3M_4)M_5)$만 존재

즉, 부분 문제들의 최적해로 n개 행렬을 곱하는 최적의 순서를 구할 수 있음

이는 최적성의 원리르 만족하므로 동적 프로그래밍 방법으로 해결 가능

## 점화식 도출

n개의 행렬 $M_i(d_{i-1} \times d_i 차원) \; (1 \leq i \leq n)$

$$
M_1(d_0 \times d_1) \times M_2(d_1 \times d_2) \times M_3(d_2 \times d_3) \times ... \times M_{n-1}(d_{n-2} \times d_{n-1}) \times M_n(d_{n-1} \times d_n)
$$

위에 공식을 응용하여 새로운 공식을 도출할 수 있음

$C(i,j) \quad 1 \leq i \leq j \leq n$

$M_i \times M_{i+1} \times M_{i+2} \times ... \times M_{j-1} \times M_j$ 를 수행하는 데 필요한 필요한 곱셈의 최소 횟수

결국은 첫 행렬부터 마지막 행렬 까지 구해야 하므로 $C(1,n) = \; ?$ 를 구하는 방법을 찾아야함

j-1=0, 1, ..., (n-1)까지 C(i, j)를 차례대로 계산

$C(i,i) = 0, \; 1 \leq i \leq n$ 는 값이 0이므로 행렬이 하나임을 나타냅니다.(비용이 없음)

$C(i,i+1) = d_{i-1}d_{i}d_{i+1}$ 는 행렬 $M_i, M_{i+1}$을 나타내므로 $M_i(d_{i-1} \times d_i) \times M_i+1(d_i \times d_{i+1})$가 되어 $d_{i-1}d_{i}d_{i+1}$이 도출됩니다. 또한 행렬의 크기는 $d_{i-1} \times d_{i+1}$가 됩니다.

$C(i, i+2) = min \{ M_i(M_{i+1}M_{i+2}) + 결합비용, (M_iM_{i+1})M_{i+2} + 결합비용 \}
$
