# 프로시저
> 일련의 작업들을 하나로 묶어서 저장해 두었다가 호출하여 이런 작업들이 실행할 수 있게 해줍니다.
```SQL
SELECT name, text FROM user_source
WHERE name LIKE (%SP_SALARY%);
```
* 프로시저 생성
```SQL
-- 저장 서브 프로그램
CREATE OR REPLACE PROCEDURE pro_noparam
IS
  V_EMPNO NUMBER(4) := 7788;
  V_ENAME VARCHAR2(10);
BEGIN
  V_ENAME := 'SCOTT';
  DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_EMPNO);
  DBMS_OUTPUT.PUT_LINE('V_ENAME : ' || V_ENAME);
END;
/
```
* 프로시저 실행
```SQL
-- 익명 블록에서 프로시저 실행하기
EXECUTE pro_noparam;
BEGIN
  pro_noparam;
END;
/

-- OUTPUT --
V_EMPNO : 7788
V_ENAME : SCOTT
```

## 프로시저에 파라미터 지정하기
> 프로시저를 생성할 때 IN, OUT, INOUT MODE를 지정하여 매개변수(Parameter)를 선언할 수 있습니다.
* IN
```SQL
-- 프로시저에 파라미터 지정하기
-- IN은 Default 값이라 선언을 따로 안해도됨
CREATE OR REPLACE PROCEDURE pro_param_in
( param1 IN NUMBER, param2 NUMBER,  param3 NUMBER := 3, param4 NUMBER DEFAULT 4)
IS
BEGIN
  DBMS_OUTPUT.PUT_LINE('param1 : ' || param1);
  DBMS_OUTPUT.PUT_LINE('param2 : ' || param2);
  DBMS_OUTPUT.PUT_LINE('param3 : ' || param3);
  DBMS_OUTPUT.PUT_LINE('param4 : ' || param4);
END;
/

-- 프로시저 실행하기
EXECUTE pro_param_in(1, 0);

-- OUTPUT --
param1 : 1
param2 : 0
param3 : 3
param4 : 4

EXECUTE pro_param_in(param1 => 10, param2 => 20);
EXECUTE pro_param_in(param2 => 20, param1 => 10);
EXECUTE pro_param_in(10, param2 => 20);

-- OUTPUT --
param1 : 10
param2 : 20
param3 : 3
param4 : 4
```

* OUT
```SQL
-- OUT
CREATE OR REPLACE PROCEDURE pro_param_out
(
  in_empno IN EMPLOYEE.ENO%TYPE,
  out_ename OUT EMPLOYEE.ENAME%TYPE,
  out_sal OUT EMPLOYEE.SALARY%TYPE
)
IS

BEGIN
  SELECT ENAME, SALARY INTO out_ename, out_sal
    FROM EMPLOYEE
   WHERE ENO = in_empno;
END pro_param_out;
/

-- OUT 모드 파라미터 사용하기
DECLARE
  v_ename EMPLOYEE.ENAME%TYPE;
  v_sal   employee.salary%type;
BEGIN
  pro_param_out(7788, v_ename, v_sal);
  DBMS_OUTPUT.PUT_LINE('ENAME : ' || v_ename);
  DBMS_OUTPUT.PUT_LINE('SAL : ' || v_sal);
END;
/

-- OUTPUT --
ENAME : SCOTT
SAL : 3000
```
* INOUT
```SQL
-- IN OUT 모드 파라미터
CREATE OR REPLACE PROCEDURE pro_param_inout
(
  inout_no IN OUT NUMBER
)
IS

BEGIN
  inout_no := inout_no * 2;
END pro_param_inout;
/

-- IN OUT 모드 파라미터 사용하기
DECLARE
  no NUMBER;
BEGIN
  no := 5;
  pro_param_inout(no);
  DBMS_OUTPUT.PUT_LINE('no : ' || no);
END;
/

-- OUTPUT --
no : 10
```

* 오류가 발생하는 프로시저
```SQL
-- 생성할 때 오류가 발생하는 프로시저 알아보기
CREATE OR REPLACE PROCEDURE pro_err
IS
  err_no NUMBER;
BEGIN
  err_no = 100;
  DBMS_OUTPUT.PUT_LINE('err_no : ' || err_no);
END pro_err;
/

SHOW ERRORS; -- 에러 발생 메시지

-- OUTPUT --
PLS-00103: Encountered the symbol "=" when expecting one of the following:     := . ( @ % ; The symbol ":= was inserted before "=" to continue. 
오류: 컴파일러 로그를 확인하십시오.
```

## 프로시저 제거
```SQL
DROP PROCEDURE PRO_NOPARAM;
```

## 프로시저 데이터 사전
```SQL
-- 프로시저 데이터 사전
SELECT NAME, TYPE, LINE, TEXT 
  FROM USER_SOURCE
 WHERE NAME = 'PRO_PARAM_IN';
```

## 에러 데이터 사전
```SQL
SHOW ERRORS; -- 에러 발생 메시지

SELECT *
  FROM USER_ERRORS
 WHERE NAME = 'PRO_ERR';
```

# 함수
> 함수는 결과를 되돌려 받기 위해서 함수가 되돌려 받게 되는 자료형과 되돌려 받을 값을 기술해야 합니다.

## 함수 생성하기
```SQL
-- 함수 생성하기
CREATE OR REPLACE FUNCTION func_aftertax(
  sal IN NUMBER
)
RETURN NUMBER
IS
  tax NUMBER := 0.05;
BEGIN
  RETURN (ROUND(sal - (sal * tax)));
END func_aftertax;
/
```
## 함수 실행하기
* PL/SQL
```SQL
DECLARE
  aftertax NUMBER;
BEGIN
  aftertax := func_aftertax(3000);
  DBMS_OUTPUT.PUT_LINE('after-tax income : ' || aftertax);
END;
/

-- OUTPUT --
after-tax income : 2850
```

* SQL
```SQL
SELECT func_aftertax(3000) FROM dual;
```
```SQL
SELECT ENO
     , ENAME
     , SALARY
     , FUNC_AFTERTAX(3000) AS AFTERTAX
  FROM EMPLOYEE;
```